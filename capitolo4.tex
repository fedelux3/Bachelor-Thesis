\chapter{Dataset e Implementazione}
\label{Dataset}
\pagestyle{empty}

La sezione seguente descrive il dataset del Boston Police Department (BPD) e l'implementazione dello Spatio-Temporal Breadth-First Miner applicato ad esso.

\section{Dataset}
Il dataset utilizzato si basa sulla raccolta dati del Department if Innovation and Technology del Boston Police Department. In questo database sono registrati tutti gli interventi sul campo che ha effettuato la polizia di Boston dal giugno 2015 fino ad oggi. \`E un servizio che viene quotidianamente aggiornato con le nuove segnalazioni.\\
Il dataset si compone di 17 colonne descritte singolarmente in Tabella 4.1.\\
\\
Per l'algoritmo oggetto del lavoro non sono necessari tutti questi dati, le informazioni fondamentali sono:
\begin{itemize}
	\item chiave di intentificazione unica 
	\item location spaziale 
	\item istante temporale 
	\item tipologia di evento 
\end{itemize}

\begin{table}[h]
	\hspace{-1cm}
	\begin{tabular}{|c|l|c|p{6cm}|}
		\hline
		\textbf{N} & \textbf{Campo} & \textbf{Tipo di dato} &  \textbf{Descrizione} \\
		\hline
		1 & INCIDENT\_NUMBER & varchar(20) & numero di report interno del BPD nonch\`e \textbf{chiave primaria} \\
		\hline
		2 & OFFENSE\_CODE & varchar(25) & numero che codifica la descrizione dell'evento \\
		\hline
		3 & OFFENSE\_CODE\_GROUP & varchar(80) & categoria di evento criminale (\textbf{tipologia}) \\
		\hline
		4 & OFFENSE\_DESCRIPTION & varchar(80) & descrizione sommaria dell'evento \\
		\hline
		5 & DISTRICT & varchar(10) & distretto cittadino \\
		\hline
		6 & REPORTING\_AREA & varchar(10) & area dalla quale \`e stato segnalato l'evento \\
		\hline
		7 & SHOOTING & char(1) & indica se vi \`e stata una sparatoria \\
		\hline
		8 & OCCURRED\_ON\_DATE & datetime(7) & data e ora in cui l'evento ha preso luogo \\
		\hline
		9 & YEAR & integer(8) & anno in cui avviene l'evento \\
		\hline
		10 & MONTH & integer(8) & mese in cui avviene l'evento \\
		\hline
		11 & DAY\_OF\_WEEK & varchar(25) & giorno della settimana in cui avviene l'evento \\
		\hline
		12 & HOUR & integer(8) & ora in cui avviene l'evento\\
		\hline
		13 & UCR\_PART & varchar(25) & Universal Crime Reporting part, codice: 1,2,3 \\
		\hline
		14 & STREET & varchar(50) & nome della via in cui l'evento \`e avvenuto \\
		\hline
		15 & LATITUDE & varchar(20) & latitudine del luogo dell'evento \\
		\hline
		16 & LONGITUDE & varchar(20) & longitudine del luogo dell'evento \\
		\hline
		17 & LOCATION & varchar(50) & latitudine e longitudine del luogo dell'evento\\
		\hline
	\end{tabular}
	\caption{attributi database BPD}
\end{table}
\clearpage

\noindent
\underline{La chiave di identificazione} del evento si pu\`o ricavare in INCIDENT\_NUMBER in quanto corrisponde alla chiave primaria del database e garantisce l'univocit\`a di valore di un evento rispetto a tutti gli altri.
\\
\underline{La location spaziale} si acquisisce dalle colonne LATITUDE e LONGITUDE. Le coordinate sono presenti nel formato digitale.
\\
\underline{L'istante temporale} viene ottenuto dall'attributo OCCURRED\_ON\_DATE. Il dato \`e registrato nel seguente formato: yyyy-MM-dd hh:mm:.\\
Ad esempio: 2018-09-01 21:28:00
\\
\underline{La tipologia di evento} si ricava dalla colonna OFFENCE\_CODE\_GROUP. L'attributo definisce le diverse tipologie di crimini pertanto \`e l'informazione in questo campo. Non \`e stato scelto l'attributo OFFENCE\_CODE in quanto le descrizioni sono troppo specifiche e poco generiche come dovrebbero essere le tipologie di eventi.\\
Inoltre si \`e scelto di analizzare i crimini di particolare gravit\`a per cercare di avere dei risultati pi\`u utili e visibili possibili. Nel database i crimini sono suddivisi in tre macro categorie denominate UCR part (Uniform Crime Reporting), seguendo uno standard americano di raccolta dati criminali. Queste categorie sono ordinate per gravit\`a: la terza categoria comprende i reati lievi quali liti e frodi, la seconda gli illeciti pi\`u gravi come vandalismo e spaccio, la prima i reati molto gravi come furto con scasso, aggressione grave e omicidio.\\
\\
Nei test effettuati si utilizzano le tipologie di crimini con UCR Part = 1, e sono i seguenti 9:
\begin{itemize}
	\item Aggravated Assault
	\item Auto Theft
	\item Commercial Burglary
	\item Homicide
	\item Other Burglary
	\item Robbery
	\item Larceny
	\item Residential Burglary 
	\item Larceny From Motor Vehicle
\end{itemize}

\noindent
\paragraph{Preprocessing} Prima di procedere all'applicazione dell'algoritmo sul database \`e stata effettuata una fase di \textit{data preprocessing} con lo scopo di eliminare i dati inconsistenti e lavorare solo su quelli significativi e coerenti.\\ 
Sono stati eliminati i record con le informazioni di LATITUDINE e LONGITUDINE vuote, inoltre sono stati eliminati valori di INCIDENT\_NUMBER duplicati. Il periodo di tempo degli eventi scelto \`e l'anno 2018. Questo perch\`e degli anni precedenti mancano riferimenti ad alcuni mesi e avrebbe potuto condizionare gli esiti dei test in quanto \`e risaputo che la frequenza di certe tipologie di eventi criminali \`e soggetta a variazioni in base alla stagione e al periodo dell'anno.\\
\\
Dopo tutte queste assunzioni i record cosiderati per il database del 2018 sono: $72135$.\\ 
Di questi si \`e deciso di considerare, per significativit\`a e compattezza nei risultati, i tipi con UCR part = 1, ovvero i reati di pi\`u alta gravit\`a, concretamente \textbf{$15648$ record} di eventi criminali. \\
Come chiaro che sia i tipi di eventi non sono ugualmente frequenti, si pu\`o notare in Figura 4.1 l'evento pi\`u rilevato \`e \textit{larceny} (furto), invece quello di intesit\`a minore \`e \textit{homicide} (omicidio).
\begin{figure}[h]
	
	\hspace{-0.5cm}
	\includegraphics[height=0.64 \linewidth]{frequenze18.png}
	\caption{frequenze eventi per classe nel 2018}
\end{figure}
\noindent
Le colonne della versione finale del database sono quelle di\\ INCIDENT\_NUMBER, OFFENCE\_CODE\_GROUP, OCCURRED\_ON\_DATE, LATITUDE, LONGITUDE.\\
In Tabella 4.2 un esempio di alcuni record del dataset:

\begin{table}[h]
	\hspace{-1.5cm}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		incident\_number & offence\_code\_group & occurred\_on\_date & latitude & longitude \\
		\hline
		I192014076 & Larceny & 20/12/2018 00:01 & 4.232.386.050 & -7.107.600.196 \\
		I192003189 & Aggr. Assault & 30/12/2018 12:00 & 4.233.596.847 & -7.108.129.856\\
		I192013746 & Larceny & 16/11/2018 12:00 & 4.232.809.966 & -7.106.321.676 \\
		I192013689 & Auto Theft & 28/12/2018 10:07 & 4.235.988.372 & -7.106.016.189 \\
		\hline
	\end{tabular}
	\caption{esempio di record nel dataset dopo preprocessing}
\end{table}
\clearpage

\section{Implementazione}
L'implementazione dell'algoritmo Spatio-Temporal Breadth-First Miner \`e stata svolta in linguaggio Python. Sono state sperimentate diverse soluzioni, di seguito vi \`e la spiegazione del funzionamento della versione migliore nonch\`e pi\`u affine all'algoritmo presentato precedentemente.\\
\\
Il software \`e diviso in due file \textit{SPTree.py} ed \textit{STBFM.py}. Il primo definisce le classi \textit{Node} ed \textit{SPTree}, responsabili della generazione e gestione della struttura ad albero. Il secondo contiene tutti i metodi e funzioni che permettono la corretta computazione dell'algoritmo.

\subsection{Node}
La classe \textit{Node} definisce la struttura dati che viene utilizzata per definire i nodi del SPTree.\\
La struttura \`e la seguente:

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|p{2.2cm}|p{1.5cm}|}
		\hline
		parent1 & parent2 & value & \centering set \mbox{(dizionario)} & children (lista) \\
		\hline
	\end{tabular}
\end{table}
\noindent
Il \textbf{parent1} e il \textbf{parent2} sono reference ad oggetti Node connessi al nodo attuale corrispondenti rispettivamente al $firstParent$ e al $secondParent$ definiti nell'albero.\\
Il \textbf{value} corrisponde al tipo di evento del nodo corrente, che varia in base alle sequenze generate e alla posizione dello stesso.\\
Il \textbf{set} si riferisce al \textit{set di istanze} calcolato fino a quel punto nella sequenza, viene salvato nel nodo in modo da non perdere l'informazione quando si dovr\`a analizzare le sequenze di lunghezza maggiore, vedi riga 5 dell'Algorithm 6. L'insieme \`e rappresentato da un dizionario in Python; \`e la struttura perfetta per questo genere di informazione perch\`e ogni istanza evento inserita viene indicizzata attraverso l'\textit{incident\_number} in questo modo risulta univoca e non duplicata nel set. Inoltre le memorizza direttamente in RAM riducendo drasticamente il numero di accessi a memoria secondaria. \\
Il campo \textbf{children} contiene una lista di reference ad oggetti Node che sono considerati "figli" del nodo corrente. La struttura della lista \`e stata scelta perch\`e dinamica e comoda nell'aggiunta ed eliminazione di elementi.\\

\subsection{SPTree}
La classe SPTree si occupa di modellare il Sequence Pattern Tree. Come struttura del nodo di base utilizza la classe \textit{Node}.\\
Come la struttura dati originale l'SPTree ho un solo attributo di base, la \textbf{root}. Essa \`e un \textit{Node} con tutti i parametri settati a \textbf{None} inizialmente. L'algoritmo esterno successivamente inserisce i \textit{children} alla root attraverso il metodo \textit{insertNode}. Un altro metodo fondamentale presente \`e \textit{searchNode} che, data una sequenza in input, ricerca e restituisce il nodo che corrisponde all'ultimo elemento della sequenza all'interno dell'albero. In questo modo posso aggiungere o eliminare nodi partendo dal termine di una sequenza e navigando con i campi del Node.