\chapter{Stato dell'Arte}
\label{Teoria}
\thispagestyle{empty}

\section{Paper}
Come precedentemente anticipato l'algoritmo oggetto di questo lavoro \`e \\
\textbf{A Novel Breadth-first Strategy Algorithm for Discovering Sequential Patterns from Spatio-temporal Data} \\ di Piotr S. Maciag e Robert Bembenik del \textit{Instituite of Computer Science, Warsaw University of Tecnology, Nowowiejska 15/19, 00-665, Warsaw, Poland}.\\ Di seguito vi \`e la trascritta la base teorica su cui si fonda l'algoritmo e le strutture dati utilizzate per la sua realizzazione.

\section{Vicinato}
Il problema che si considera \`e quello della scoperta di pattern da un certo dataset di istanze di eventi, i quali sono di una certa tipologia, definiamo quindi:

$D \rightarrow$ dataset di istanze di eventi

$F \rightarrow$ insieme di tipologie di eventi
\\\\
Ogni istanza $e \in D$ ha:
\begin{itemize}
	\item chiave di identificazione (unica)
	\item location spaziale (es. coordinate geografiche)
	\item istante temporale
	\item tipologia $f \in F$
\end{itemize}
\noindent
La sequenza di eventi (pattern) \`e cos\`i definita:

$\overrightarrow{s} = f_{i_1} \rightarrow f_{i_2} \rightarrow ... \rightarrow f_{i_n}$, dove $f_{i_1}, f_{i_2}, ..., f_{i_n} \in F$\\
Quindi per ogni due tipologie di eventi consecutive in una sequenza $f_{i_{j-1}} \rightarrow f_{i_j}$, le istanze dell'evento $j-1$ sono connesse con con il tipo successivo spazialmente e temporalmente. \\
L'insieme di eventi collegati in questo modo a una determinata istanza viene definito \textbf{neighborhood} o  vicinato. 

\underline{Esempio}\\
Consideriamo una situazione come quella in Fig. 2.1, dove:\\
$D = \{a1,a2,b1,b2,b3,b4,b5,b6,b7,b8,c1,c2,c3,c4\}$\\
$F = \{A,B,C\}$
\begin{figure}[h!]
	\centering
	\includegraphics[height=0.6 \linewidth]{neighborhood.png}
	\caption{esempio di istanze con vicinato degli eventi di tipo A}
\end{figure}
\\
Una sequenza significativa per esempio potrebbe essere $\overrightarrow{s} = A \rightarrow B \rightarrow C$.\\
Per valutare la connessione $A \rightarrow B$ bisogna considerare il \textit{neighborhood} tra le loro istanze. Come si nota dalla figura \`e stato scelto un raggio spaziale pari a $R = 3.5$ e un intervallo temporale pari a $T = 10$ per la dimensione del vicinato. 

\section{Nozioni di base}
Dopo aver inquadrato graficamente il problema ora definiamo formalmente i concetti base usati per il calcolo di tutte le sequenze pattern usati nell'algoritmo.

\paragraph{Spazio Neighborhood} Con $V_{N(e)}$ denotiamo lo spazio di neighborhood (vicinato) dell'istanza $e$. Questo spazio si basa su tre dimensioni, che sono le due dimensioni spaziali - latitudine e longitudine - e la dimensione temporale. Graficamente ne risulta un cilindro, con parametri $R$ che denota il raggio spaziale e $T$ l'intervallo temporale.

In Figura 2.2 vengono mostrati i due neighborhood tratti dall'\textit{esempio} della Figura 2.1: $V_{N(a1)}$ e $V_{N(a2)}$.

\begin{figure}[h!]
	\centering
	\includegraphics[height=0.2 \linewidth]{neia1.png}\hfil
	\includegraphics[height=0.2 \linewidth]{neia2.png}
	\caption{$V_{N(a1)}$ e $V_{N(a2)}$}
\end{figure}

\paragraph{Neighborhood rispetto a una tipologia di evento} Data una certa istanza $e$, il \textit{neighborhood} di $e$ \`e definito nel modo seguente:\\

$N_f(e) = \{e|p \in D(f) $

\qquad \qquad $\wedge$ $distance(p.location, e.location) \leq R$ 

\qquad \qquad $\wedge$ $(p.time - e.time) \in [0,T]\}$\\
\\
dove $R$ e $T$ sono i parametri dello spazio di vicinato $V_{N(e)}$ e $D(f)$ \`e l'insieme di istanze degli eventi di tipo $f$ nel dataset $D$.

\noindent \underline{Nota} si considerano solo gli eventi che si susseguono dal punto di vista temporale, in quanto \`e poco significativo considerare gli eventi passati dell'istanza nella ricerca di sequenze.
\\\\
Riassumento con $N_f(e)$ denoto l'insieme di istanze di tipo $f$ contenute all'interno dello spazio $V_{N(e)}$.
\\
Nel nostro \textit{esempio} della Figura 2.2: \\
$N_B(a1) = \{b1,b2,b3\}$ e $N_B(a2) = \{b4,b5,b6\}$

\paragraph{Set di istanze} Per una sequenza di tipi di eventi $\overrightarrow{s} = \overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m]$ di lunghezza $m$, gli insiemi (set) di istanze $I(\overrightarrow{s}[1]),I(\overrightarrow{s}[2]),...,I(\overrightarrow{s}[m])$ che sono inclusi nella sequenza $\overrightarrow{s}$ sono definiti come segue: 
\begin{enumerate}
	\item Per un tipo di evento $\overrightarrow{s}[1]$, il set di istanze $I(\overrightarrow{s}[1])$ \`e definito come:

	\qquad $I(\overrightarrow{s}[1]) = D(\overrightarrow{s}[1])$
	
	\item Per i tipi $\overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m]$ con $i = 2,3, ..., m$, gli insiemi di istanze $I(\overrightarrow{s}[i]$ sono definiti cos\`i:
	
	\qquad $I(\overrightarrow{s}[i]) = distinct( \underset{e \in I(\overrightarrow{s}[i-1])}{\bigcup} N_{\overrightarrow{s}[i]}(e))$	
\end{enumerate}
\noindent
In pratica per il primo tipo di evento (d'ora in poi nominato solo "tipo") che partecipa alla sequenza $\overrightarrow{s}$, il set di istanze $I(\overrightarrow{s}[1])$ corrisponde al set di istanze di tipo $\overrightarrow{s}[1]$ in $D$, ovvero $D(\overrightarrow{s}[1])$.\\
Per i tipi successivi di $\overrightarrow{s}$, i set $I(\overrightarrow{s}[i])$ sono definiti come insiemi di istanze contenute nei vicinati di istanze a partire da $I(\overrightarrow{s}[i-1])$.\\
Seguendo questo meccanismo si valuta tutta la sequenza e tendendo in considerazione l'insieme di istanze calcolato al passaggio precedente.
\\\\
Consideriamo la sequenza $\overrightarrow{s} = A \rightarrow B$ dal dataset dell'\textit{esempio} in Figura 2.1. In questo caso avremmo i seguenti set di istanze:\\
$I(\overrightarrow{s}[1]) = \{a1,a2\}$\\
$I(\overrightarrow{s}[2]) = \{b1,b2,b3,b4,b5,b6\}$

\paragraph{Participation Ratio} Data una sequenza $\overrightarrow{s} = \overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m]$ il \textit{participation rateo} tra due tipi consecutivi contenuti in $\overrightarrow{s}$ \`e definito:\\

$PR(\overrightarrow{s}[i-1] \rightarrow \overrightarrow{s}[i]) =$ {\large$\frac{|I(\overrightarrow{s}[i])|}{|D(\overrightarrow{s}[i])|}$}\\
\\
questo valore corrisponde al numero di istanze distinte di tipo $\overrightarrow{s}[i]$ contenute nei neighborhoods delle istanze di tipo $\overrightarrow{s}[i-1]$ diviso il numero di istanze di tipo $\overrightarrow{s}[i]$ presenti nel dataset $D$.\\
Per ogni coppia di tipi consecutivi ($\overrightarrow{s}[i-1]$, $\overrightarrow{s}[i]$) in una sequenza $\overrightarrow{s}$ il \textit{participation rateo} \`e definito come il rapporto tra $|I(\overrightarrow{s}[i])|$ e $|D(\overrightarrow{s}[i])|$ e il suo valore \`e compreso nel range $[0,1]$.

\paragraph{Participation Index} Data una sequenza lunga $m$: $\overrightarrow{s} = \overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m]$, il \textit{participation index} \`e cos\`i definito:
\begin{enumerate}
	\item se $m = 2$:
	
	\qquad $PI(\overrightarrow{s}) = PR(\overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2])$
	
	\item se $m > 2$:
	
	\qquad $PI(\overrightarrow{s}) = min
	\begin{cases}
		PI(\overrightarrow{s}^\ast) \\ PR(\overrightarrow{s}[m-1] \rightarrow \overrightarrow{s}[m]
	\end{cases} 
	$
\end{enumerate}
dove $\overrightarrow{s}^\ast = \overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m-1]$\\
\\
Il \textit{participation index} corrisponde al minimo di tutti i \textit{participation rateo} calcolati su due tipi consecutivi presenti in $\overrightarrow{s}$, ed \`e il nostro valore di output dell'algoritmo.\\
Intuitivamente lo possiamo pensare come il numero di istanze di eventi collegate alle istanze di tipi connessi precedentemente secondo un ordine stabilito dalla sequenza e questo ci d\`a la misura di quanto la sequenza sia correlata.\\
\\
Consideriamo il nostro \textit{esempio} della Figura 2.1, per la sequenza $\overrightarrow{s} = A \rightarrow B$ il $PI(\overrightarrow{s}) = 0.75$ ($PI(A \rightarrow B) = PR(A \rightarrow B) = \frac{6}{8} = 0.75)$ che \`e un buon risultato di correlazione. 

\section{Albero - SPTree}
A sostegno dell'algoritmo viene definita una struttura ad albero dedicata per ridurre drasticamente il numero delle computazioni, in particolare per quanto riguarda la generazione di sequenze candidato nuove.\\
\\
INSERIRE DEFINIZIONE DI ALBERO DAL CORMAN
\\\\
Consideriamo un insieme di tipi di eventi di questo tipo: $F = \{A,B,C,D,E,F\}$ e un insieme $L$ di sequenze pattern presentate in Tabella 2.1.
\clearpage
\begin{table}[h]
	\centering
	\begin{tabular}{l c}
		\hline
		$F$ & $A,B,C,D,E,F$ \\
		\hline
		$L$ & Sequenze pattern \\
		\hline
		$L_2$ & $A \rightarrow B$, $ B \rightarrow C$, $B \rightarrow D$, $C \rightarrow E$, $C \rightarrow F$. \\
		$L_3$ & \parbox{0.4\textwidth}{$A \rightarrow B \rightarrow C$, $A \rightarrow B \rightarrow D$, $B \rightarrow C \rightarrow E$, $B \rightarrow C \rightarrow F$.}	\\
		$L_4$ & $A \rightarrow B \rightarrow C \rightarrow E$, $A \rightarrow B \rightarrow C \rightarrow F$.\\
		\hline
	\end{tabular}
	\caption{esempio di sequenze pattern}
\end{table}
\noindent
Partendo dalla radice verranno inserite tutte le sequenze significative secondo i criteri che seguono.\\\\
La \textbf{root} avr\`a come figli tutti i tipi di eventi presenti in $F$. Assumiamo che le sequenze di lunghezza 2 ($L_2$) siano state generate dai tipi di partenza effettuando tutte le combinazioni tra di essi, con le verifiche del participation rateo come presentato dal $L_2$ dell'albero in Figura 2.3.\\
\\
Per ogni sequenza, quindi ogni nodo dell'albero, utilizziamo tre strutture di dati: \textit{firstParent}, \textit{secondParent} e \textit{children}.\\
Per la generazione dei \textbf{nodi} si procede per livello, ovvero ci si basa sul livello immediatamente precedente e si genera quello sottostante, seguendo queste procedure:
\begin{itemize}
	\item se la sequenza $\overrightarrow{s}$ \`e stata creata unendo i tipi di eventi $f_{i_1}$ e $f_{i_2}$ a $\overrightarrow{s} = f_{i_1} \rightarrow f_{i_2}$, allora:\\
	\textit{firstParent}$(\overrightarrow{s}) := f_{i_1}$\\ \textit{secondParent}$(\overrightarrow{s}) := f_{i_2}$\\
	$\overrightarrow{s}$ viene aggiunta ai \textit{children}$(\overrightarrow{s})$
	
	\item se la sequenza $\overrightarrow{s}$ \`e stata creata dalle sequenze $\overrightarrow{s}_i$ e $\overrightarrow{s}_j$, allora:\\ \textit{firstParent}$(\overrightarrow{s}) := \overrightarrow{s}_i$\\ \textit{secondParent}$(\overrightarrow{s}) := \overrightarrow{s}_j$\\
	$\overrightarrow{s}$ viene aggiunta ai \textit{children}$(\overrightarrow{s})$
\end{itemize}
\clearpage
\begin{figure}[h!]
	\centering
	\includegraphics[height=0.5 \linewidth]{sptree.png}
	\caption{SPTree basato sulle sequenze della Tabella 2.1}
\end{figure}
\textit{Esempio} Consideriamo la sequenza $A \rightarrow B$ dalla Tabella 2.1 e quindi la sua memorizzazione nel \textit{SPTree} come in Figura 2.3. Assumiamo che dobbiamo generare i candidati di lunghezza 3 quindi generare il terzo livello dell'albero.\\
In questo caso $A \rightarrow B$ pu\`o essere estesa con due diversi tipi $C$ o $D$, in quanto $A \rightarrow B$ ha come \textit{secondParent} il tipo $B$ ed esso ha come sequenze figlio (\textit{children}) $B \rightarrow C$ e $B \rightarrow D$, pertanto le posso aggiungere alla sequenza $A \rightarrow B$.\\
Seguendo questo processo viene generato l'\textit{SPTree}.
\section{STBFM}
dfghj
\section{Alternativa - Algoritmo apriori}

