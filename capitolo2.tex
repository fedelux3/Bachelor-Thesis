\chapter{Base teorica}
\label{Teoria}
\thispagestyle{empty}

\section{Paper}
Come precedentemente anticipato l'algoritmo oggetto di questo lavoro \`e \\
\textbf{A Novel Breadth-first Strategy Algorithm for Discovering Sequential Patterns from Spatio-temporal Data} \\ di Piotr S. Maciag e Robert Bembenik del \textit{Instituite of Computer Science, Warsaw University of Tecnology, Nowowiejska 15/19, 00-665, Warsaw, Poland}.\\ Di seguito vi \`e la trascritta la base teorica su cui si fonda l'algoritmo e le strutture dati utilizzate per la sua realizzazione.

\section{Vicinato}
Il problema che si considera \`e quello della scoperta di pattern da un certo dataset di istanze di eventi, i quali sono di una certa tipologia, definiamo quindi:

$D \rightarrow$ dataset di istanze di eventi

$F \rightarrow$ insieme di tipologie di eventi
\\\\
Ogni istanza $e \in D$ ha:
\begin{itemize}
	\item chiave di identificazione (unica)
	\item location spaziale (es. coordinate geografiche)
	\item istante temporale
	\item tipologia $f \in F$
\end{itemize}
\noindent
La sequenza di eventi (pattern) \`e cos\`i definita:

$\vec{s} = f_{i_1} \rightarrow f_{i_2} \rightarrow ... \rightarrow f_{i_n}$, dove $f_{i_1}, f_{i_2}, ..., f_{i_n} \in F$\\
Quindi per ogni due tipologie di eventi consecutive in una sequenza $f_{i_{j-1}} \rightarrow f_{i_j}$, le istanze dell'evento $j-1$ sono connesse con con il tipo successivo spazialmente e temporalmente. \\
L'insieme di eventi collegati in questo modo a una determinata istanza viene definito \textbf{neighborhood} o  vicinato. 

\underline{Esempio}\\
Consideriamo una situazione come quella in Fig. 2.1, dove:\\
$D = \{a1,a2,b1,b2,b3,b4,b5,b6,b7,b8,c1,c2,c3,c4\}$\\
$F = \{A,B,C\}$
\begin{figure}[h!]
	\centering
	\includegraphics[height=0.6 \linewidth]{neighborhood.png}
	\caption{esempio di istanze con vicinato degli eventi di tipo A}
\end{figure}
\\
Una sequenza significativa per esempio potrebbe essere $\vec{s} = A \rightarrow B \rightarrow C$.\\
Per valutare la connessione $A \rightarrow B$ bisogna considerare il \textit{neighborhood} tra le loro istanze. Come si nota dalla figura \`e stato scelto un raggio spaziale pari a $R = 3.5$ e un intervallo temporale pari a $T = 10$ per la dimensione del vicinato. 

\section{Nozioni di base}
Dopo aver inquadrato graficamente il problema ora definiamo formalmente i concetti base usati per il calcolo di tutte le sequenze pattern usati nell'algoritmo.

\paragraph{Spazio Neighborhood} Con $V_{N(e)}$ denotiamo lo spazio di neighborhood (vicinato) dell'istanza $e$. Questo spazio si basa su tre dimensioni, che sono le due dimensioni spaziali - latitudine e longitudine - e la dimensione temporale. Graficamente ne risulta un cilindro, con parametri $R$ che denota il raggio spaziale e $T$ l'intervallo temporale.

In Figura 2.2 vengono mostrati i due neighborhood tratti dall'\textit{esempio} della Figura 2.1: $V_{N(a1)}$ e $V_{N(a2)}$.

\begin{figure}[h!]
	\centering
	\includegraphics[height=0.2 \linewidth]{neia1.png}\hfil
	\includegraphics[height=0.2 \linewidth]{neia2.png}
	\caption{$V_{N(a1)}$ e $V_{N(a2)}$}
\end{figure}

\paragraph{Neighborhood rispetto a una tipologia di evento} Data una certa istanza $e$, il \textit{neighborhood} di $e$ \`e definito nel modo seguente:

$N_f(e) = \{e|p \in D(f) $

\qquad \qquad $\wedge$ $distance(p.location, e.location) \leq R$ 

\qquad \qquad $\wedge$ $(p.time - e.time) \in [0,T]\}$
\\
dove $R$ e $T$ sono i parametri dello spazio di vicinato $V_{N(e)}$ e $D(f)$ \`e l'insieme di istanze degli eventi di tipo $f$ nel dataset $D$.

\noindent \underline{Nota} si considerano solo gli eventi che si susseguono dal punto di vista temporale, in quanto \`e poco significativo considerare gli eventi passati dell'istanza nella ricerca di sequenze.
\\\\
Riassumento con $N_f(e)$ denoto l'insieme di istanze di tipo $f$ contenute all'interno dello spazio $V_{N(e)}$.
\\
Nel nostro \textit{esempio} della Figura 2.2: \\
$N_B(a1) = \{b1,b2,b3\}$ e $N_B(a2) = \{b4,b5,b6\}$

\paragraph{Set di istanze} Per una sequenza di tipi di eventi $\vec{s} = \vec{s}[1] \rightarrow \vec{s}[2] \rightarrow ... \rightarrow \vec{s}[m]$ di lunghezza $m$, gli insiemi (set) di istanze $I(\vec{s}[1]),I(\vec{s}[2]),...,I(\vec{s}[m])$ che sono inclusi nella sequenza $\vec{s}$ sono definiti come segue: 
\begin{enumerate}
	\item Per un tipo di evento $\vec{s}[1]$, il set di istanze $I(\vec{s}[1])$ \`e definito come:

	\qquad $I(\vec{s}[1]) = D(\vec{s}[1])$
	
	\item Per i tipi $\vec{s}[2] \rightarrow ... \rightarrow \vec{s}[m]$ con $i = 2,3, ..., m$, gli insiemi di istanze $I(\vec{s}[i]$ sono definiti cos\`i:
	
	\qquad $I(\vec{s}[i]) = distinct( \underset{e \in I(\vec{s}[i-1])}{\bigcup} N_{\vec{s}[i]}(e))$	
\end{enumerate}
\noindent
In pratica per il primo tipo di evento (d'ora in poi nominato solo "tipo") che partecipa alla sequenza $\vec{s}$, il set di istanze $I(\vec{s}[1])$ corrisponde al set di istanze di tipo $\vec{s}[1]$ in $D$, ovvero $D(\vec{s}[1])$.\\
Per i tipi successivi di $\vec{s}$, i set $I(\vec{s}[i])$ sono definiti come insiemi di istanze contenute nei vicinati di istanze a partire da $I(\vec{s}[i-1])$.\\
Seguendo questo meccanismo si valuta tutta la sequenza e tendendo in considerazione l'insieme di istanze calcolato al passaggio precedente.
\\\\
Consideriamo la sequenza $\vec{s} = A \rightarrow B$ dal dataset dell'\textit{esempio} in Figura 2.1. In questo caso avremmo i seguenti set di istanze:\\
$I(\vec{s}[1]) = \{a1,a2\}$\\
$I(\vec{s}[2]) = \{b1,b2,b3,b4,b5,b6\}$

\paragraph{Participation Ratio}
	
\paragraph{Participation Index}


\section{Parametri di threshold}

\section{Struttura ad albero}

\section{Alternativa - Algoritmo apriori}

