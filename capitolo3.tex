\chapter{Algoritmo}
\label{Algoritmo}
\thispagestyle{empty}

\section{STM Algorithm}
Definiti i concetti teorici di base, ora verr\`a descritto l'algoritmo Spatio-Temporal Miner che permette di trovare tutte le sequenze pattern con \textit{participation index} maggiori di una certa soglia \textbf{threshold} $\theta$ data dall'utente.\\
La definizione di un $\theta$ permette, da un lato, di considerare come risultato solo le sequenze pi\`u significative e, dall'altro, ignorare dalla computazione quelle che hanno un livello di correlazione troppo basso. \\
Naturalmente bisogna considerare che l'utente definisce il parametro $\theta$ ma anche il raggio spaziale $R$ e l'intervallo temporale $T$ che sono imprescindibili per il calcolo del neighborhood.

\begin{algorithm}[h]
	\KwData{D - dataset delle istanze degli eventi, F - insieme di tipi di eventi, R - raggio spaziale, T - intervallo temporale, $\theta$ - threshold}
	\KwResult{\textit{Top} - insieme delle $N$ sequenze pi\`u significative}
		
	\nl $C_2 :=$ generazione candidati di lunghezza 2\\
	\nl $L_2 :=$ VerifyCandidates($C_2$)\\
	\nl $k = 3$\\
	\nl \While{$L_{k-1} \ne \emptyset$}{
		\nl $C_k :=$ CandidateGen($L_{k-1}$)\\
		\nl $L_k :=$ VerifyCandidates($C_k$)\\
		\nl Add $L_k$ to $L$\\
		\nl $k := k + 1$	
	} 
	\nl \textbf{return} $L$
	
	\caption{Spatio-temporal breath first miner for discovering significant sequential patterns (STBFM)}
\end{algorithm}

\noindent
\paragraph{Algorithm 1} L'algoritmo che sta alla base di tutto \`e l'Algorithm 1. Inizialmente genera le sequenze candidato di lunghezza 2, unendo ciascun tipo con tutti gli altri in modo da coprire tutte le combinazioni possibili. Per tutte queste sequenze viene calcolato il \textit{set di istanze} e basandosi su questo si calcolano i \textit{participation index} (PI) attraverso la funzione VerifyCandidates.\\
Nella fase che segue vengono generate le sequenze candidato del livello successivo ($C_k$) attraverso la funzione CandidateGen (riga 5), con calcolo dei \textit{set di istanze} annessi. Successivamente vengono calcolati i valori di PI associati alle sequenze appena generate ($L_k$), sempre utilizzando la funzione VerifyCandidates (riga 6). \\
Queste operazioni avvengono per ogni livello iterativamente finch\`e il livello precedente ($k-1$) non sia vuoto.
Tutti questi risultati vengono registrati nella famiglia di insiemi $L$ che verr\`a poi ritornata.  

\begin{algorithm}[H]
	\KwData{$C_m$ - insieme di candidati sequenze di tipi di lunghezza $m$, $\theta$ - threshold}
	\KwResult{$L_m$ - insieme di sequenze di tipi significativi di lunghezza $m$}
	
	\nl $C_m := \emptyset$ \\
	\nl \ForEach{$\overrightarrow{s} \in C_m$}{
		\nl CalculatePI($\overrightarrow{s}$)\\
		\nl \If{$PI(\overrightarrow{s}) \ge \theta$}{
			\nl Add $\overrightarrow{s}$ to $L_m$\\	
		}
	}
	\nl \textbf{return} $L_m$
	
	\caption{VerifyCandidates}
\end{algorithm}

\paragraph{Algorithm 2} L'Algorithm 2 ha il compito di verificare le sequenze candidato. Questa verifica consiste nel calcolo del \textit{participation index} della sequenza e se questo valore supera il threshold $\theta$ allora la si accetta, altrimenti si rifiuta. Questa valutazione viene effettuata iterativamente per tutte le sequeze candidato. \\
Il calcolo del PI viene effettuato seguendo la definizione nella sua applicazione nell'\textbf{Algorithm 4}.

\begin{algorithm}[H]
	\KwData{$L_{m-1}$ - insieme di sequenze di tipi di lunghezza $m - 1$}
	\KwResult{$C_m$ - insieme di candidati sequenze di tipi di lunghezza $m$}
	\nl $C_m := \emptyset$\\
	\nl \ForEach{$\overrightarrow{s_i} \in L_{m-1} $}{
		\nl \ForEach{$\overrightarrow{s_j} \in L_{m-1} \wedge \overrightarrow{s_i} \ne \overrightarrow{s_j}$}{
			\nl \If{$\overrightarrow{s_i}[2] = \overrightarrow{s_j}[1] \wedge \overrightarrow{s_i}[3] = \overrightarrow{s_j}[2] \wedge ... \wedge \overrightarrow{s_i}[m] = \overrightarrow{s_j}[m-1]$}{
				\nl $\overrightarrow{s} := \overrightarrow{s_i}[1] \rightarrow \overrightarrow{s_i}[2] \rightarrow ... \rightarrow \overrightarrow{s_i}[m-1] \rightarrow \overrightarrow{s_j}[m-1]$\\
				\nl $I(\overrightarrow{s}[1]) := I(\overrightarrow{s_i}[1]) \wedge I(\overrightarrow{s}[2]) := I(\overrightarrow{s_i}[2]) \wedge ... \wedge $\\$I(\overrightarrow{s}[m-1]) := I(\overrightarrow{s_i}[m-1]) \wedge$\\$ I(\overrightarrow{s}[m]) :=$  CalculateNeighborhood$(I(\overrightarrow{s_i}[m-1]),I(\overrightarrow{s_j}[m-1])$\\
				\nl Add $\overrightarrow{s}$ to $C_m$
			}	
		}
	}
	\nl \textbf{return} $C_m$
	
	\caption{CandidateGen($L_{m-1})$}
\end{algorithm}

\paragraph{Algorithm 3} L'Algorithm 3 genera un insieme di sequenze candidato di lunghezza $m$ basate sulle sequenze gi\`a analizzate di lunghezza $m-1$. \\
La generazione avviene secondo la seguente logica: \\
due sequenze di lunghezza $m-1$ si uniscono per creare una nuova sequenza di lunghezza $m$, se contengono gli stessi tipi di eventi in certe posizioni: il secondo tipo della prima sequenza \`e uguale al primo tipo della seconda sequenza, il terzo tipo della prima sequenza \`e uguale al secondo tipo della seconda sequenza e cos\`i via finch\`e l'ultimo tipo della prima sequenza non \`e uguale al penultimo tipo della seconda sequenza.

\textit{Esempio}:\\
$P_1 = \{ A \rightarrow B \rightarrow C \rightarrow D \}$ (sequenza lunga $m-1$)\\
$P_2 = \{ B \rightarrow C \rightarrow D \rightarrow E \}$ (sequenza lunga $m-1$)\\
$P_{new} = \{ A \rightarrow B \rightarrow C \rightarrow D \rightarrow E\}$ (sequenza lunga $m$)\\
Come si pu\`o notare, la nuova sequenza ha tutti i tipi della prima e come ultimo elemento l'ultimo tipo della seconda sequenza.\\
Per quanto riguarda il calcolo del \textit{set di istanze} (riga 6) ci sono 2 possibili casi:
\begin{enumerate}
	\item per i tipi di eventi dal primo al penultimo elemento della sequenza, il set di istanze \`e lo stesso di quello della prima sequenza quindi di $I(\overrightarrow{s_i}[m-1])$
	\item per l'ultimo tipo di eventi, il set di istanze \`e dato dal neighborhood che c'\`e tra il penultimo tipo (che corrisponde al set di istanze della prima sequenza) e l'ultimo tipo della seconda sequenza, ovvero\\ CalculateNeighborhood$(I(\overrightarrow{s_i}[m-1]), I(\overrightarrow{s_j}[m-1]))$
\end{enumerate}
Per il calcolo del vicinato si utilizza la definizione applicata nell'\textbf{Algorithm 5}.

\paragraph{Algorithm 4} L'Algorithm 4 definisce il calcolo del \textit{participation index} come definito dalla formula: $PI(\overrightarrow{s}) = min
\begin{cases}
PI(\overrightarrow{s}^\ast) \\ PR(\overrightarrow{s}[m-1] \rightarrow \overrightarrow{s}[m]
\end{cases} 
$

\begin{algorithm}[h]
	\KwData{$\overrightarrow{s} = \overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m-1] \rightarrow \overrightarrow{s}[m]$ - una sequenza di tipi di eventi}
	\nl \textbf{return} $min(PI(\overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m-1]), PR(\overrightarrow{s}[m-1] \rightarrow \overrightarrow{s}[m])$\\
	
	\caption{CalculatePI$(\vec{s})$}
\end{algorithm}

\paragraph{Algorithm 5} L'Algorithm 5 si occupa del calcolo del neighborhood. Esso si applica secondo la definizione data in precedenza, per\`o non prendendo i dati direttamente dal dataset. Si considera $I(\overrightarrow{s_i}[m-1])$ come set di partenza e si considera il vicinato con l'ultimo elemento della seconda sequenza $I(\overrightarrow{s_j}[m-1])$. 
\begin{algorithm}[h]
	\KwData{$I(\overrightarrow{s_i}[m-1])$ - un insieme di istanze di tipo $\overrightarrow{s}[m]$ della sequenza $\overrightarrow{s_i}$, $I(\overrightarrow{s_j}[m-1])$ - un insieme di istanze di eventi di tipo $\overrightarrow{s_j}[m]$ della sequenza $\overrightarrow{s}_j$}
	\KwResult{$I(\overrightarrow{s}[m])$ - un insieme di istanze di eventi di tipo $\overrightarrow{s}[m]$ della sequenza candidato $\overrightarrow{s}$}
	
	\nl \textbf{return} $I(\overrightarrow{s}[i])$ as $ distinct( \underset{e \in I(\overrightarrow{s_i}[m-1])}{\bigcup} N_{\overrightarrow{s_j}[m-1]}(e))$	
	\caption{CalculateNeighborhood($I(\vec{s_i}[m-1]), I(\vec{s_j}[m-1])$)}
\end{algorithm}

Come si pu\`o da subito notare il carico coputazionale pi\`u pesante lo si ha nell'Algorithm 3, la CandidateGen. In quest'ultimo bisogna valutare tutte le possibili coppie di sequenze del livello precedente se sono compatibili tra loro per generare le nuove sequenze del livello successivo e i rispettivi set di istanze. \\
Se consideriamo anche solo un dataset di 10.000 record con 20 tipi di eventi, significa che l'algoritmo itera sui 10.000 record migliaia di volte per ciascuna sequenza da generare. \\
Certamente un threshold $\theta$ alto ci permette di ignorare diverse combinazioni,  per\`o \`e un parametro handmade. Pertanto se si sceglie un $\theta$ troppo alto si rischia di avere pochi risultati con PI molto alto, se si sceglie un $\theta$ troppo bassso si rischia di considerare troppe sequenze che dilaterebbero troppo i tempi di computazione. \\
\\
Per questi motivi viene definita una nuova struttura ad albero per evitare moltissime di queste computazioni (SPTree) e viene migliorato l'algoritmo in modo da rendere il parametro $\theta$ variabile in base al numero di risultati significativi, come vediamo di seguito.

\clearpage

\section{Albero - SPTree}
A sostegno dell'algoritmo viene definita una struttura ad albero dedicata per ridurre drasticamente il numero delle computazioni, in particolare per quanto riguarda la generazione di sequenze candidato nuove. \\
L'albero \`e chiamato Sequence Pattern Tree (SPTree).\\
\\
INSERIRE DEFINIZIONE DI ALBERO DAL CORMAN
\\\\
Consideriamo un insieme di tipi di eventi di questo tipo: $F = \{A,B,C,D,E,F\}$ e un insieme $L$ di sequenze pattern presentate in Tabella 3.1.

\begin{table}[h]
	\centering
	\begin{tabular}{l c}
		\hline
		$F$ & $A,B,C,D,E,F$ \\
		\hline
		$L$ & Sequenze pattern \\
		\hline
		$L_2$ & $A \rightarrow B$, $ B \rightarrow C$, $B \rightarrow D$, $C \rightarrow E$, $C \rightarrow F$. \\
		$L_3$ & \parbox{0.4\textwidth}{$A \rightarrow B \rightarrow C$, $A \rightarrow B \rightarrow D$, $B \rightarrow C \rightarrow E$, $B \rightarrow C \rightarrow F$.}	\\
		$L_4$ & $A \rightarrow B \rightarrow C \rightarrow E$, $A \rightarrow B \rightarrow C \rightarrow F$.\\
		\hline
	\end{tabular}
	\caption{esempio di sequenze pattern}
\end{table}
\noindent
Partendo dalla radice verranno inserite tutte le sequenze significative secondo i criteri che seguono.\\\\
La \textbf{root} avr\`a come figli tutti i tipi di eventi presenti in $F$. Assumiamo che le sequenze di lunghezza 2 ($L_2$) siano state generate dai tipi di partenza effettuando tutte le combinazioni tra di essi, con le verifiche del \textit{participation rateo} come presentato dal $L_2$ dell'albero in Figura 3.1.\\
\\
Per ogni sequenza, ovvero ogni nodo dell'albero, utilizziamo tre strutture di dati: \textit{firstParent}, \textit{secondParent} e \textit{children}.\\
Per la generazione dei \textbf{nodi} si procede per livello, ovvero ci si basa sul livello immediatamente precedente e si genera quello sottostante, seguendo queste procedure:
\begin{itemize}
	\item se la sequenza $\overrightarrow{s}$ \`e stata creata unendo i tipi di eventi $f_{i_1}$ e $f_{i_2}$ a $\overrightarrow{s} = f_{i_1} \rightarrow f_{i_2}$, allora:\\
	\textit{firstParent}$(\overrightarrow{s}) := f_{i_1}$\\ \textit{secondParent}$(\overrightarrow{s}) := f_{i_2}$\\
	$\overrightarrow{s}$ viene aggiunta ai \textit{children}$(\overrightarrow{s})$
	
	\item se la sequenza $\overrightarrow{s}$ \`e stata creata dalle sequenze $\overrightarrow{s}_i$ e $\overrightarrow{s}_j$, allora:\\ \textit{firstParent}$(\overrightarrow{s}) := \overrightarrow{s}_i$\\ \textit{secondParent}$(\overrightarrow{s}) := \overrightarrow{s}_j$\\
	$\overrightarrow{s}$ viene aggiunta ai \textit{children}$(\overrightarrow{s})$
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[height=0.5 \linewidth]{sptree.png}
	\caption{SPTree basato sulle sequenze della Tabella 3.1}
\end{figure}
\textit{Esempio}\\
Consideriamo la sequenza $A \rightarrow B$ dalla Tabella 3.1 e quindi la sua memorizzazione nel \textit{SPTree} come in Figura 2.3. Assumiamo che dobbiamo generare i candidati di lunghezza 3 quindi generare il terzo livello dell'albero.\\
In questo caso $A \rightarrow B$ pu\`o essere estesa con due diversi tipi $C$ o $D$, in quanto $A \rightarrow B$ ha come \textit{secondParent} il tipo $B$ ed esso ha come sequenze figlio (\textit{children}) $B \rightarrow C$ e $B \rightarrow D$, pertanto le posso aggiungere alla sequenza $A \rightarrow B$.\\
Seguendo questo processo viene generato l'\textit{SPTree}.
\clearpage

\section{STBFM}

\begin{algorithm}[H]
	\KwData{$L_{m-1}$ - insieme di sequenze di tipi di lunghezza $m - 1$}
	\KwResult{$C_m$ - insieme di candidati sequenze di tipi di lunghezza $m$}
	\nl $C_m := \emptyset$\\
	\nl \ForEach{$\overrightarrow{s_i} \in L_{m-1} $}{
		\nl \ForEach{$\overrightarrow{s_j} \in children(secondParent(\overrightarrow{s_i}))$}{
			\nl $\overrightarrow{s} := \overrightarrow{s_i}[1] \rightarrow \overrightarrow{s_i}[2] \rightarrow ... \rightarrow \overrightarrow{s_i}[m-1] \rightarrow \overrightarrow{s_j}[m-1]$\\
			\nl $I(\overrightarrow{s}[1]) := I(\overrightarrow{s_i}[1]) \wedge I(\overrightarrow{s}[2]) := I(\overrightarrow{s_i}[2]) \wedge ... \wedge $\\$I(\overrightarrow{s}[m-1]) := I(\overrightarrow{s_i}[m-1]) \wedge$\\ $I(\overrightarrow{s}[m]) :=$  CalculateNeighborhood$(I(\overrightarrow{s_i}[m-1]),I(\overrightarrow{s_j}[m-1])$\\
			\nl $firstParent(\overrightarrow{s}) := \overrightarrow{s_i}, secondParent(\overrightarrow{s}) := \overrightarrow{s_j}$\\
			\nl Add $\overrightarrow{s}$ to $children(\overrightarrow{s_i})$, Add $\overrightarrow{s}$ to $C_m$	
		}
	}
	\nl \textbf{return} $C_m$
	
	\caption{CandidateGen($L_{m-1})$}
\end{algorithm}

\begin{algorithm}[H]
	\KwData{$C_m$ - insieme di candidati sequenze di tipi di lunghezza $m$, $\theta$ - threshold}
	\KwResult{$L_m$ - insieme di sequenze di tipi significativi di lunghezza $m$}
	
	\nl $C_m := \emptyset$ \\
	\nl \ForEach{$\overrightarrow{s} \in C_m$}{
		\nl CalculatePI($\overrightarrow{s}$)\\
		\nl \If{$PI(\overrightarrow{s}) \ge \theta$}{
			\nl Add $\overrightarrow{s}$ to $L_m$\\	
		}
		\nl \Else{
			\nl Remove $\overrightarrow{s}$ from $children(firstParent(s))$
		}
	}
	\nl \textbf{return} $L_m$
	
	\caption{VerifyCandidates}
\end{algorithm}

\begin{algorithm}
	\KwData{$C_m$ - un insieme di sequenze pattern candidato di lunghezza $m$, $\theta$ - threshold}
	
	\nl $L_m := \emptyset$\\
	\nl \ForEach{$\overrightarrow{s} \in C_m$}{
		\nl CalculatePI($\overrightarrow{s}$)\\
		\nl \If{PI($\overrightarrow{s} \ge \theta$)}{
			\nl \If{$|Top| < N-1$}{
				\nl Add $\overrightarrow{s}$ to $L_m$, add $\overrightarrow{s}$ to $Top$
			} 
			\nl \ElseIf{$|Top| = N-1$}{
				\nl Add $\overrightarrow{s}$ to $L_m$, add $\overrightarrow{s}$ to $Top$\\
				\nl $\theta := PI(Top(N))$	
			}
		}
		\nl \Else{
			\nl Add $\overrightarrow{s}$ to $L_m$, add $\overrightarrow{s}$ to $Top$\\
			\nl \If{PI($\overrightarrow{s} > \theta$)}{
				\nl $\theta := $ PI($Top(N)$)\\
				\nl Delete all $\overrightarrow{s} \in Top$ with PI($\overrightarrow{s}$) $< \theta$\\
				\nl Delete all $\overrightarrow{s} \in L_m$ with PI($\overrightarrow{s}$) $< \theta$\\
				\nl Delete $\overrightarrow{s}$ from $children(firstParent(\overrightarrow{s}))$
			}
		}
		\nl \Else{
			\nl Remove $\overrightarrow{s}$ from $children(firstParent(\overrightarrow{s}))$
		}
	}
	\nl \textbf{return} $L_m$
	
	\caption{Top-N-VerifyCandiatesSPTree($C_m$)}
\end{algorithm}

\section{Alternativa - Algoritmo apriori}

