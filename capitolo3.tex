\chapter{Algoritmo}
\label{Algoritmo}
\thispagestyle{empty}

\section{STM Algorithm}
Definiti i concetti teorici di base ora verr\`a descritto l'algoritmo Spatio-Temporal Miner che permette di trovare tutte le sequenze pattern con \textit{participation index} maggiori di una certa soglia \textbf{threshold} $\theta$ data dall'utente.\\
La definizione di un $\theta$ permette di considerare come risultato solo le sequenze pi\`u significative e ignorare dalla computazione, invece, quelle che hanno un livello di correlazione troppo basso. \\
Naturalmente bisogna considerare che l'utente definisce il parametro $\theta$ ma anche il raggio spaziale $R$ e l'intervallo temporale $T$.


\begin{algorithm}[h]
	\KwData{D - dataset delle istanze degli eventi, F - insieme di tipi di eventi, R - raggio spaziale, T - intervallo temporale, $\theta$ - threshold}
	\KwResult{\textit{Top} - insieme delle $N$ sequenze pi\`u significative}
		
	\nl $C_2 :=$ generazione candidati di lunghezza 2\\
	\nl $L_2 :=$ VerifyCAndidates($C_2$)\\
	\nl $k = 3$\\
	\nl \While{$L_{k-1} \ne \theta$}{
		\nl $C_k :=$ CandidateGen($C_2$)\\
		\nl $L_k :=$ VerifyCandidates($C_k$)\\
		\nl Add $L_k$ to $L$\\
		\nl $k := k + 1$	
	} 
	\nl \textbf{return} $L$
	
	\caption{Spatio-temporal breath first miner for discovering significant sequential patterns (STBFM)}
\end{algorithm}

\begin{algorithm}[h]
	\KwData{$C_m$ - insieme di candidati sequenze di tipi di lunghezza $m$, $\theta$ - threshold}
	\KwResult{$L_m$ - insieme di sequenze di tipi significativi di lunghezza $m$}
	
	\nl $C_m := \emptyset$ \\
	\nl \ForEach{$\overrightarrow{s} \in C_m$}{
		\nl CalculatePI($\overrightarrow{s}$)\\
		\nl \If{$PI(\overrightarrow{s}) \ge \theta$}{
			\nl Add $\overrightarrow{s}$ to $L_m$\\	
		}
	}
	\nl \textbf{return} $L_m$
	
	\caption{VerifyCandidates}
\end{algorithm}

\begin{algorithm}[h]
	\KwData{$L_{m-1}$ - insieme di sequenze di tipi di lunghezza $m - 1$}
	\KwResult{$C_m$ - insieme di candidati sequenze di tipi di lunghezza $m$}
	\nl $C_m := \emptyset$\\
	\nl \ForEach{$\overrightarrow{s_i} \in L_{m-1} $}{
		\nl \ForEach{$\overrightarrow{s_j} \in L_{m-1} \wedge \overrightarrow{s_i} \ne \overrightarrow{s_j}$}{
			\nl \If{$\overrightarrow{s_i}[2] = \overrightarrow{s_j}[1] \wedge \overrightarrow{s_i}[3] = \overrightarrow{s_j}[2] \wedge ... \wedge \overrightarrow{s_i}[m] = \overrightarrow{s_j}[m-1]$}{
				\nl $\overrightarrow{s} := \overrightarrow{s_i}[1] \rightarrow \overrightarrow{s_i}[2] \rightarrow ... \rightarrow \overrightarrow{s_i}[m-1] \rightarrow \overrightarrow{s_j}[m-1]$\\
				\nl $I(\overrightarrow{s}[1]) := I(\overrightarrow{s_i}[1]) \wedge I(\overrightarrow{s}[2]) := I(\overrightarrow{s_i}[2]) \wedge ... \wedge $\\$I(\overrightarrow{s}[m-1]) := I(\overrightarrow{s_i}[m-1]) \wedge I(\overrightarrow{s}[m]) :=$  CalculateNeighborhood$(I(\overrightarrow{s_i}[m-1]),I(\overrightarrow{s_j}[m-1])$\\
				\nl Add $\overrightarrow{s}$ to $C_m$
			}	
		}
	}
	\nl \textbf{return} $C_m$
	
	\caption{CandidateGen($L_{m-1})$}
\end{algorithm}

\begin{algorithm}[h]
	\KwData{$\overrightarrow{s} = \overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m-1] \rightarrow \overrightarrow{s}[m]$ - una sequenza di tipi di eventi}
	\nl \textbf{return} $min(PI(\overrightarrow{s}[1] \rightarrow \overrightarrow{s}[2] \rightarrow ... \rightarrow \overrightarrow{s}[m-1]), PR(\overrightarrow{s}[m-1] \rightarrow \overrightarrow{s}[m])$\\
	
	\caption{CalculatePI$(\vec{s})$}
\end{algorithm}

\begin{algorithm}[h]
	\KwData{$I(\overrightarrow{s_i}[m-1])$ - un insieme di istanze di tipo $\overrightarrow{s}[m]$ della sequenza $\overrightarrow{s_i}$, $I(\overrightarrow{s_j}[m-1])$ - un insieme di istanze di eventi di tipo $\overrightarrow{s_j}[m]$ della sequenza $\overrightarrow{s}_j$}
	\KwResult{$I(\overrightarrow{s}[m])$ - un insieme di istanze di eventi di tipo $\overrightarrow{s}[m]$ della sequenza candidato $\overrightarrow{s}$}
	
	\nl \textbf{return} $I(\overrightarrow{s}[i])$ as $ distinct( \underset{e \in I(\overrightarrow{s}[i-1])}{\bigcup} N_{\overrightarrow{s}[i]}(e))$	
	\caption{CalculateNeighborhood($I(\vec{s_i}[m-1]), I(\vec{s}[m-1])$)}
\end{algorithm}

\section{Albero - SPTree}
A sostegno dell'algoritmo viene definita una struttura ad albero dedicata per ridurre drasticamente il numero delle computazioni, in particolare per quanto riguarda la generazione di sequenze candidato nuove.\\
\\
INSERIRE DEFINIZIONE DI ALBERO DAL CORMAN
\\\\
Consideriamo un insieme di tipi di eventi di questo tipo: $F = \{A,B,C,D,E,F\}$ e un insieme $L$ di sequenze pattern presentate in Tabella 2.1.
\clearpage
\begin{table}[h]
	\centering
	\begin{tabular}{l c}
		\hline
		$F$ & $A,B,C,D,E,F$ \\
		\hline
		$L$ & Sequenze pattern \\
		\hline
		$L_2$ & $A \rightarrow B$, $ B \rightarrow C$, $B \rightarrow D$, $C \rightarrow E$, $C \rightarrow F$. \\
		$L_3$ & \parbox{0.4\textwidth}{$A \rightarrow B \rightarrow C$, $A \rightarrow B \rightarrow D$, $B \rightarrow C \rightarrow E$, $B \rightarrow C \rightarrow F$.}	\\
		$L_4$ & $A \rightarrow B \rightarrow C \rightarrow E$, $A \rightarrow B \rightarrow C \rightarrow F$.\\
		\hline
	\end{tabular}
	\caption{esempio di sequenze pattern}
\end{table}
\noindent
Partendo dalla radice verranno inserite tutte le sequenze significative secondo i criteri che seguono.\\\\
La \textbf{root} avr\`a come figli tutti i tipi di eventi presenti in $F$. Assumiamo che le sequenze di lunghezza 2 ($L_2$) siano state generate dai tipi di partenza effettuando tutte le combinazioni tra di essi, con le verifiche del participation rateo come presentato dal $L_2$ dell'albero in Figura 2.3.\\
\\
Per ogni sequenza, quindi ogni nodo dell'albero, utilizziamo tre strutture di dati: \textit{firstParent}, \textit{secondParent} e \textit{children}.\\
Per la generazione dei \textbf{nodi} si procede per livello, ovvero ci si basa sul livello immediatamente precedente e si genera quello sottostante, seguendo queste procedure:
\begin{itemize}
	\item se la sequenza $\overrightarrow{s}$ \`e stata creata unendo i tipi di eventi $f_{i_1}$ e $f_{i_2}$ a $\overrightarrow{s} = f_{i_1} \rightarrow f_{i_2}$, allora:\\
	\textit{firstParent}$(\overrightarrow{s}) := f_{i_1}$\\ \textit{secondParent}$(\overrightarrow{s}) := f_{i_2}$\\
	$\overrightarrow{s}$ viene aggiunta ai \textit{children}$(\overrightarrow{s})$
	
	\item se la sequenza $\overrightarrow{s}$ \`e stata creata dalle sequenze $\overrightarrow{s}_i$ e $\overrightarrow{s}_j$, allora:\\ \textit{firstParent}$(\overrightarrow{s}) := \overrightarrow{s}_i$\\ \textit{secondParent}$(\overrightarrow{s}) := \overrightarrow{s}_j$\\
	$\overrightarrow{s}$ viene aggiunta ai \textit{children}$(\overrightarrow{s})$
\end{itemize}
\clearpage
\begin{figure}[h!]
	\centering
	\includegraphics[height=0.5 \linewidth]{sptree.png}
	\caption{SPTree basato sulle sequenze della Tabella 2.1}
\end{figure}
\textit{Esempio} Consideriamo la sequenza $A \rightarrow B$ dalla Tabella 2.1 e quindi la sua memorizzazione nel \textit{SPTree} come in Figura 2.3. Assumiamo che dobbiamo generare i candidati di lunghezza 3 quindi generare il terzo livello dell'albero.\\
In questo caso $A \rightarrow B$ pu\`o essere estesa con due diversi tipi $C$ o $D$, in quanto $A \rightarrow B$ ha come \textit{secondParent} il tipo $B$ ed esso ha come sequenze figlio (\textit{children}) $B \rightarrow C$ e $B \rightarrow D$, pertanto le posso aggiungere alla sequenza $A \rightarrow B$.\\
Seguendo questo processo viene generato l'\textit{SPTree}.
\section{STBFM}
dfghj
\section{Alternativa - Algoritmo apriori}

